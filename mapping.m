function point = mapping (Constellation, InputBits)
[~,l] = size(InputBits); %Количество символов во входном массиве, благодаря которому можно узнать количество точек, которые необходимо обработать
switch Constellation
    case 'BPSK'
        BPSK_value=[1 0;-1 -0]; %Массив, содержащий все возможные варианты BPSK
        for iB = 1:l %Цикл, строящий несколько точек за раз
            numberB(iB)=bi2de(InputBits(iB),2,'left-msb')+1; %Определяем номер точки в созвездии заданного типа,+1 нужен для того, чтобы начать нумерацию не с 0, а с 1
            x(iB)=BPSK_value(numberB(iB),1); %Определяем абциссу, извлекая нужное значение из массива, хранящего все значения BPSK
            y(iB)=BPSK_value(numberB(iB),2); %Определяем ординату, извлекая нужное значение из массива, хранящего все значения BPSK
        end
        point = complex(x,y); %Переменная, которая содержит в себе результат построения в виде комплексного числа
    case 'QPSK'
        QPSK_value=[1 1;1 -1;-1 1;-1 -1]; %Массив, содержащий все возможные варианты QPSK
        a = Norm(QPSK_value); %Вызываем метод нормировки по мощности точек всех точек созвездия
        countQ=1; %Инициализируем счётчик для разделения битового потока на отдельные 2х битовые точки
        for iQ1 = 1:l/2 %Два цикла, режущие входящий битовый поток на точки, каждая из которых имеет 2 бита
            for iQ2 = 1:2  
                pointQ(iQ1,iQ2) = InputBits(countQ); %Двумерный массив, содержащий все битовые коды всех точек. Каждая строчка - это отдельная точка. 4 столбика, в каждом столбике свой бит для конкретной точки
                countQ = countQ+1;
            end
        end
        for iQ3 = 1:l/2 %Цикл, строящий несколько точек за раз
            numberQ(iQ3)=bi2de(pointQ(iQ3,:),2,'left-msb')+1;
            x(iQ3)=real(a(numberQ(iQ3)));
            y(iQ3)=imag(a(numberQ(iQ3)));
        end
        point = complex(x,y); %Переменная, которая содержит в себе результат построения в виде комплексного числа
    case '16-QAM'
        QAM_value=[3,3;3,1;1,3;1,1;3,-3;3,-1;1,-3;1,-1;-3,3;-3,1;-1,3;-1,1;-3,-3;-3,-1;-1,-3;-1,-1]; %Массив, содержащий все возможные варианты 16-QAM
        a = Norm(QAM_value); %Вызываем метод нормировки по мощности точек всех точек созвездия
        count=1; %Инициализируем счётчик для разделения битового потока на отдельные 4х битовые точки
        for i16_1 = 1:l/4 %Два цикла, режущие входящий битовый поток на точки, каждая из которых имеет 4 бита
            for i16_2 = 1:4  
                point(i16_1,i16_2) = InputBits(count); %Двумерный массив, содержащий все битовые коды всех точек. Каждая строчка - это отдельная точка. 4 столбика, в каждом столбике свой бит для конкретной точки
                count = count+1;
            end
        end
        for i16 = 1:l/4 %Цикл, строящий несколько точек за раз
            number16(i16)=bi2de(point(i16,:),2,'left-msb')+1; %Определяем номер точки в созвездии заданного типа,+1 нужен для того, чтобы начать нумерацию не с 0, а с 1
            x(i16)=real(a(number16(i16))); %Определяем абциссу, извлекая нужное значение из комплексного массива, хранящего все нормированные значения 16-QAM
            y(i16)=imag(a(number16(i16))); %Определяем ординату, извлекая нужное значение из комплексного массива, хранящего все нормированные значения 16-QAM
        end
        point = complex(x,y); %Переменная, которая содержит в себе результат построения в виде комплексного числа
end
%Paint(x,y, Constellation); %Вызываем функцию отрисовки точек на комплексной плоскости
end
function [a] = Norm(value)
[lN,~] = size(value);
    for iN1=1:lN
        z(iN1)=complex(value(iN1,1),value(iN1,2)); 
    end
    sum=0;
    for iN2=1:lN
        sum=sum+z(iN2)*conj(z(iN2));
    end
    n=sqrt(sum/lN);
    for iN3=1:lN
        a(iN3)=z(iN3)/n; 
    end 
end
%Функция, которая строит созвездие на комплексной плоскости по заданным действительной и мнимой частям. Также она принимает название созвездия
function Paint(x,y,heder)
   plot(x,y, 'x');
   xlim([-3.5,3.5]);
   ylim([-3.5,3.5]);
   grid on;
   title(heder);
   ylabel('Quadrature');
   xlabel('In-Phase');
end
